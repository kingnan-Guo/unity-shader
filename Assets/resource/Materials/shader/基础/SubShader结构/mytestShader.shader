Shader "TechShader/mytestShader"
{
    Properties
    {
        // _Name ("Name", type) = defaultVaule[{options}]
        // _Name ("Name", int) = number // 整形
        // _Name ("Name", Float) = number // 浮点型 更多使用
        // _Name ("Name", Range(min, max)) = number // 范围浮点
        _MainTex ("Texture", 2D) = "white" {}
        _MyInt ("Int", int) = 10
        _MyFloat ("Float", Float) = 10.0
        _MyRange ("Range", Range(0.0, 100.0)) = 10.0

        // 颜色 取值范围 0～1 rgba
        _Color ("Color", Color) = (1,1,1,0.5)
        // 向量 XYZW
        _Vector ("Vector", Vector) = (1,1,1,1)
        // 贴图纹理类型
        _My2D("My2D", 2D) = "White"{}
        _MyCube("MyCube", cube) = ""{}

        //
        _My2DArray("My2DArray", 2DArray) = "{}"
        _My3D("My3D", 3D) = "{}"


    }
    //1、渲染标签 通过逼哦啊钱来确定 什么时候 以及 如何 对物体进行渲染
    //2、 渲染状态 通过状态来确定 渲染时 的 剔除方式，深度测试方式 混合方式 等 内容
    //3、渲染通道 居图实现着色器代码的 地方（每个subshader语句块中 至少 有一个渲染通道 可以有很多）
    //   - 在 subshander 中 没定义一个渲染 通道 pass  就会让 物体执行一次 渲染
    //   - n个 pass 就会有n此渲染， 在实现一些负载的渲染效果 时 需要使用 多个 pass  进行 组合 实现
    //   -  更多的 pass 会 增加 性能消耗
    //4、 渲染队列 渲染队列 决定 渲染顺序 以及 渲染的优先级

    SubShader
    {
        // 1、 渲染标签
        // Tags{"标签名称1“ = “标签值1” "标签名称2“ = “标签值2” }


        // 队列 ------------------------
        // BackGround （背景） （队列号 1000）
        // 最早被渲染的物体的队列 ， 一般 来渲染 天空盒 或者 背景
         // "Queue"="BackGround" // 渲染队列

        // Geometry （几何） （队列号 2000）
        // 几何体 队列 ， 一般 来渲染 模型 或者 地形； 不同命的 几何体 通常使用该 队列  ，当没有声明 渲染队列时  unity 会 默认使用这个 队列
        // Tags { "Queue" = "Geometry"}

        // AlphaTest （透明测试） （队列号 2450）
        // 透明测试 队列 ， 一般 来渲染 透明物体; 
        // 有透明通道的 需要进行 ALpha 测试的集合体会 使用该队列
        // 当所有的 Geometry 队列实体 绘制完 后再绘制  AlphaTest 队列 ，效率更高
        // Tags { "Queue" = "AlphaTest"}



        // Transparent （透明） （队列号 3000）
        // 透明队列 ， 一般 来渲染 半透明物体
        // 半透明物体 需要进行 透明测试 以及 深度测试
        // 该队列中i和体按照 有远道进的顺序来 进行绘制 ，半透明的 物体的渲染队列 ， 所有 进行透明混合的集合体都 应该 使用 该队列
        // 比如 玻璃材质 粒子特效
        // Tags { "Queue" = "Transparent"}

        // Overlay （叠加） （队列号 4000）
        //  是放在最后的 悬案的队列 于叠加渲染的效果 比如警惕呀光晕 等
        // Tags { "Queue" = "Overlay"}


        // 自定义 队列
        // 基于 unity  预先定义号的 这些渲染队列标签来进行加减 运算 来定义自己的 渲染队列
        // 比如 
        // Tags { "Queue" = "Geometry+1" }  // 代表 2001
        // Tags { "Queue" = "Transparent-1" }  // 代表 2999
        // Tags { "Queue" = "CustomQueue100"}


        // 比如  一些 水  的渲染 想要在不透明 物体之后， 半透明物体 之前 进行渲染，就可以自定义

        // 自定义队列只能给予 预先定义号的 各个类型 进行计算， 不能在 shader 中直接 赋值 数字， （可以在 材质面板中设置）
        // 比如 
        // Tags { "Queue" = "1000 + 100"}  // 错误
        // Tags { "Queue" = "1000 + 1000"}  // 正确


        // 渲染队列 标签 只能使用 预先定义号的 渲染队列标签
        // 比如 
        // Tags { "Queue" = "1000 + 100"}  // 错误
        // Tags { "Queue" = "CustomQueue100"}  // 正确



        // RenderType ==================================

        
        // Opaque （不透明 的）
        // 用于普通  shader 比如 不同命 自发光 反射

        //2】 Transparent （透明）
        // 用于透明shader 不如 透明 粒子
        //3 TransparentCutout （透明切割）
        //eg：植物叶子
        // background 背景
        // 用于天空盒 shader
        // Overlay 覆盖
        // 用于 FUI纹理 、halo （光环）、 Flare （光晕）
        

        // 通过 摄像机的 api  再利用 上面所写的 类型，摄像机的api 就可以找到 对应的类型 把对应类型的subshader 的代码 替换成另一个 shader 里相关的代码


        // 禁用批处理 ===================
        // 主要作用
        // 当 使用批处理时，模型绘本变换到 世界空间 模型空间会被丢弃 
        // 可能都会导致 某些使用 模型空间顶点 数据的shader、 最终 无法实现想要的结果
        // 可以 通过 开启禁用批处理来解决问题
        // 特殊的shader 会直接使用模型顶点去计算的时候 才会 去禁用 批处理

        // 
        // 总是禁用 
        // Tags {
        //     "DisableBatching" = "True"
        // }

        // Tags {
        //     "DisableBatching" = "False"
        // }

        // LOD 效果激活的时候才会禁用 批处理



        //  禁用 阴影 投影 =================
        
        // Tags {
        //     "ForceNoShadowCasting" = "True"
        // }
        
        // 忽略 投影机
        // 主要 Projector 投影机的 投射
        // Projector 是 unity 中的 一个功能
        // 忽略 projector （一般半透明 shander 需要开启该 标签）

        // Tags {
        //     "IgnoreProjector" = "True"
        // }

        // 其他标签 =========
        
        // 1 是否用于精灵
        // 想要 将 该 subshader 用于 sprite 将 该标签设置 为False
        // tags {"CanUseSpriteAtlas" = "False"}

        // 预览类型
        // 材质在预览窗口 默认 为 球星 想要改变为平面 或者 天空盒
        // 只需要改变预览 标签即可

        // 平面
        // tags {"PreviewType" = "Plane"}
        // 天空盒
        // tags {"PreviewType" = "Skybox"}



        // 2、 渲染状态
        /// 渲染状态 相关 ================

        // 片元 ： 在渲染管线中 片元市值在光栅化 阶段生成的 像素 挥着像素 片段
        // 片元是渲染管线中进行像素级别 操作和计算 的基本单位
        // 每个片元达标了屏幕上的一个像素 并且具有位置信息 和与之相关的属性
        // 比如 颜色 深度值  法线 等

        // ------- 语法结构 -------
        // 渲染状态 状态类型
        // 渲染状态 是痛殴 渲染状态管检测 +  状态类型 决定的
        // 如果存在 多个渲染状态
        // 可以通过空行 隔开

        //  LOD 200


        // ------- 剔除方式 --------
        // 设置多边形的 剔除方式 又被免提出 正面剔除 不剔除
        // 所谓的题粗 就是不渲染 背面 剔除 就是背面不渲染， 正面剔除 就是 正面不渲染
        // 不剔除 就是 都渲染
        
        // Cull Back 背面剔除
        // Cull Front 正面剔除
        // Cull Off 都不剔除

        // 不设置的话 默认为 背面 剔除
        // 一般情况下 我们需要浪面渲染时  会设置 为 不剔除



        // ------- 深度写入 --------
        // 深度测试流程 、 混合流程（这两个阶段 都在渲染管线 光栅话阶段只能够的 逐片元操作中 进行）
        // 首先 判断是否 通过 深度测试，
        // 判断 模型设在前 谁在后  是要 通过 Z 是否写入到  深度缓存 来帮助比较的

        // 如果上面 的物体 是半透明 那么这个物体就不能写入 深度缓存 区  

        // ----  深度 缓冲

        // 是否写入 深度 缓冲
        // 深度缓冲 （Depth Buffer）
        // 深度换成是一个 与屏幕像素对应的 缓冲区 用于 存储每个像素的深度值（距离相机的距离）
        // 在渲染 场景之卡进 深度缓冲 被初始化为最大深度，表示所有像素到早相机 之外

        // ZWrite On 写入深度缓冲
        // ZWrite Off 关闭写入深度缓冲

        // 默认是 写入 
        // 深度写入 就是 深度缓冲区 是否写入 深度值

        // 一般情况下 在做透明等 特殊效果时  会设置为不写入


        // ------- 深度测试 --------
        // 深度测试 的 对比方式
        // 深度测试 主要的目的 确保在渲染时，像素按照正确的深度（距离 相机的距离 ） 属性进行绘制
        // 从而创建正确的遮挡关系和 透视效果
        // 在渲染场景之前 名数吨缓冲 被初始化 为最大深度， 表示所有像素都在相机之外
        // 在渲染过程中 对于每个像素深度测试 会将当前像素的深度值 与 深度缓冲中对应位置的值  进行比较
        // 一般情况下如果 当前 像素的深度值 小于深度缓冲 中的值 说明 当前像素在其他物体之前， 他会呗绘制，并更新深度缓冲
        // 如果当前像素深度大于 等于 深度缓冲中的值，说明 当前像素在其他物体之后， 他会被丢弃 不会被 绘制，保持深度 缓冲不变

        // ZTest Less 小于当前深度缓冲中的值就通过测试 写入到深度缓冲中 （要看是上面是否开启）
        // ZTest Greater 大于当前深度缓冲中的值就通过测试 写入到深度缓冲中
        // ZTest LEqual 小于等于当前深度缓冲中的值就通过测试 写入到深度缓冲中
        // ZTest GEqual 大于等于当前深度缓冲中的值就通过测试 写入到深度缓冲中
        // ZTest Equal 等于当前深度缓冲中的值就通过测试 写入到深度缓冲中
        // ZTest NotEqual 不等于当前深度缓冲中的值就通过测试 写入到深度缓冲中
        // ZTest Always 总是通过测试 写入到深度缓冲中

        // 默认是 Equal

        // 一般情况下， 我们只有在 实现一些特殊效果时才会修改深度测试方式， 比如透明物体 渲染会修改为 Less ，描边效果会 修改为Greate

        // ------ 混合方式 ----------
        // 深度测试 ->> 混合 ->> 颜色缓冲区（存储屏幕中的 像素的颜色）
        // 每次深度 测试 后 都会执行 混合
        
        // 混合就是 把当前的颜色 与 缓冲区 的颜色混合 计算，计算完成后 在存入到 颜色缓冲区（存储屏幕中的

        // 最终留下来的 颜色 就是屏幕中 看到的颜色

        // 设置 渲染图像的  混合的方式（多种颜色 叠加混合 比如透明、半透明和遮挡物体颜色混合）

        // Blend One One       线性减淡
        // Blend SrcAlpha OneMinusSrcAlpha 半透明 正常透明混合
        // Blend SrcAlpha One OneMinusSrcAlpha 透明
        // Blend SrcAlpha SrcAlpha 透明
        // Blend OneMinusDstColor OneMinusDstColor 滤色
        // Blend DstColor Zrero    正片叠加
        // Blend DstColor SrcColor X光片效果
        // Blend One OneMinusSrcAlpha 透明度混合
        // ....
        // 不设置的话 默认 不会进行混合

        // 一般情况下 我们需要多种颜色  叠加渲染时 ，就需要设置混合方式，具体情况具体处理



        // ----- 其他渲染状态 ------

        // 1、LOD 控制LOD级别,  在不同 距离下使用不同的渲染方式处理； 如果加载 pass 上，不同的 渲染通道pass 使用 不同的 1、LOD
        // 2、 ColorMask 设置颜色的通道写入蒙版，默认蒙版 为RGBA ; (遮照)
        // 3、 ZClip 设置深度缓冲区 是否 进行裁剪，默认是 关闭的
        // 4、 ZTest 深度测试 
        // 5、 ZWrite 深度写入
        // 6、 Cull 剔除方式
        // 7、 Blend 混合方式
        // 8、 ZOffset 深度偏移
        // 9、 Offset 偏移
        // 10、 Clip 裁剪
        // 11、 ClipPlane 裁剪平面
        // 12、 ClipThreshold 裁剪阈值
        // 13、 ZTest  深度测试 


        // ------- 渲染状态 注意事项 ----
        // 以上这些状态不仅可以在subShader 语句块中声明
        //之后 pass 渲染通道语句 块中 也可以神明这些 渲染状态
        // 如果在subshader 语句块中适应会影响之后的 所有 渲染通道 pass
        // 如果在pass 语句块中使用 只会影响当前 pass 渲染通道， 不会影响其他的pass

      



        

        

      

        // 3、 渲染通道
        pass    // 第一个渲染 通道
        {
            // Name: "myTestShaderPassOne" // 其他shader 可以通过此名字 找到 此pass 进行复用
            // usePass "Custom/myShaderTwo/PASSOME" // 复用其他shader 的 pass  会被自动转为 大写

            // pass 中的渲染 标签
            // Tags{"标签名称1“ = “标签值1” "标签名称2“ = “标签值2” }‘
            // pass 中 有自己专门的渲染标签
            // Tags {"LightMode = “标签值1” }‘// 主要作用 该 pass 应该在那个阶段执行
            // 可以 将着色器 代码分配给当前的 巡查阶段 以实现所需的需的效果

            // LightMode
            // Always  // 始终渲染，不应用 光照
            // ForwardBase  // 基础光照； 在向前渲染中 使用， 应用 环境光 主方向光 顶点/SH 光源 和光照贴纸
            // ForwardAdd  // 基础光照 并 添加 光照；在向前渲染中 使用，应用附加的每像素光源（每个光源有一个通道）
            // ShadowCaster  // 渲染阴影； 将对象深度渲染到 阴影贴图或 上年度纹理中
            // MotionVectors  // 用于计算 每对象 运动 矢量
            // prepassBase  // 基础渲染， 用于 预计算 阴影贴图； 在旧版延迟光照中使用，渲染法线 和镜面反射指数
            // prepassFinal  // 基础渲染， 用于 预计算 阴影贴图； 在旧版延迟光照中使用 通过组合纹理 ， 光照和反光来渲染最终颜色
            // vertex  // 顶点渲染；当 对象不进行光照 贴图时 在旧版顶点光照渲染中使用，应用所有 顶点 光源
            // vertexLMRGB  // 顶点渲染 并 添加 光照； 当 对象不进行光照 贴图时 在旧版顶点光照渲染中使用，在光照贴图为RGBM 编码 的平台上（PC 和 游戏主机）
            // vertexLM  // 顶点渲染 并 添加 光照； 当 对象不进行光照 贴图时 在旧版顶点光照渲染中使用，在光照图 为双 LDR 编码的 平台上 （移动平台）
             
    
            //--------
            // 用于指定当满足某些 条件 时 才渲染 pass
            // Tags {"RequireOptions = 标签值 }

            // 目前 unity 仅支持
            // Tags {"RequireOptions = “softVegetation” }
            // 仅当 Quality 窗口开启了 softVegetation 时才渲染此通道

            // -------
            // Tags {"PassFlags" = "标签值" }
            // 主要作用： 一个渲染通道 pass 可指示 一些比哦啊值来更改渲染管线 向 pass 创书数据方式

            // 目前 unity 仅支持
            // Tags {"PassFlags“ = ”OnlyDirectional“ }
            // 在 ForwardBase 向前渲染的通道类型中 使用， 此标志的作用时仅允许 主方向主方向 光和环境光 / 光照探针数据传递 到着色器
            // 这意味着非重要 光源的数据 将不会传递到顶点光源 或 球谐函数 着色器变量

            
            // ========== pass 中的 渲染 状态 =====================
            // 如果 在 subshader 语句块中 使用会 影响之后的所有 渲染通道pass
            // 如果 在 pass 语句块中 使用 只会影响当前的 渲染通道 pass
            // 不仅如此 pass 中 还可以 使用固定管线着色器的 命令

            
            // ====== 其他着色器代码 =====
            // 可能会使用 CG 或者 HLSL 等 着色器语言来进行偶寄书写


            // ======= GrabPass 命令 =======
            // 我们可以利用 GrabPass 命令吧即将绘制的屏幕内容抓取到纹理中
            // 在后续听到中即可使用此纹理， 从而执行基于图像的高级效果

            // eg：
            // 将绘制该对枪之前的屏幕抓取到 _BackgroundTexture 中，
            // GrabPass{
            //     "_BackgroundTexture"
            // }
            // 注意该命令一般写在 某个pass 前， 之后的 pass 代码中可以利用 _BackgroundTexture 变量进行处理

            

        }
        pass
        {
            // 第二个渲染 通道

        }

        // FallBack "Diffuse"// 备用着色器； Diffuse 老版本 shader 的 名字
        // FallBack Off 没有  备用
        // 自定义的 要写 shader 的路径  和名字
        // 如果所有的 subshader 都无法执行 那么 这个物体就不会 被渲染出来


    }
}




